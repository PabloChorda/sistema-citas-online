"""Añadir modelos AvailabilityRule, TimeBlock, Appointment y relaciones actualizadas

Revision ID: 7eda8673006f
Revises: d148cc319a91
Create Date: 2025-05-21 19:43:42.801302

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql # Importante para postgresql.ENUM


# revision identifiers, used by Alembic.
revision = '7eda8673006f'
down_revision = 'd148cc319a91'
branch_labels = None
depends_on = None


# Definimos los valores del ENUM aquí para claridad y para pasarlos a postgresql.ENUM
appointment_status_enum_values = ('PENDING_PROVIDER', 'CONFIRMED', 'CANCELLED_BY_CLIENT', 'CANCELLED_BY_PROVIDER', 'COMPLETED', 'NO_SHOW')
appointment_status_type_name = 'appointmentstatustype' # Nombre del tipo ENUM en PostgreSQL

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # --- Creación del tipo ENUM de PostgreSQL para AppointmentStatus ---
    # Creamos el tipo ENUM antes de crear la tabla que lo usa.
    op.execute(f"CREATE TYPE {appointment_status_type_name} AS ENUM{appointment_status_enum_values};")

    op.create_table('availability_rules',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('provider_id', sa.Integer(), nullable=False),
    sa.Column('day_of_week', sa.Integer(), nullable=False), # Correcto, ya que tu modelo usa Integer
    sa.Column('start_time', sa.Time(), nullable=False),
    sa.Column('end_time', sa.Time(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['provider_id'], ['providers.provider_id'], name=op.f('fk_availability_rules_provider_id_providers'), ondelete='CASCADE'), # Añadido 'name' para el fk
    sa.PrimaryKeyConstraint('id', name=op.f('pk_availability_rules')) # Añadido 'name' para el pk
    )
    with op.batch_alter_table('availability_rules', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_availability_rules_provider_id'), ['provider_id'], unique=False)

    op.create_table('time_blocks',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('provider_id', sa.Integer(), nullable=False),
    sa.Column('start_datetime', sa.DateTime(timezone=True), nullable=False),
    sa.Column('end_datetime', sa.DateTime(timezone=True), nullable=False),
    sa.Column('reason', sa.String(length=255), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['provider_id'], ['providers.provider_id'], name=op.f('fk_time_blocks_provider_id_providers'), ondelete='CASCADE'), # Añadido 'name'
    sa.PrimaryKeyConstraint('id', name=op.f('pk_time_blocks')) # Añadido 'name'
    )
    with op.batch_alter_table('time_blocks', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_time_blocks_provider_id'), ['provider_id'], unique=False)

    op.create_table('appointments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('client_id', sa.Integer(), nullable=True),
    sa.Column('provider_id', sa.Integer(), nullable=False),
    sa.Column('service_id', sa.Integer(), nullable=True),
    sa.Column('start_datetime', sa.DateTime(timezone=True), nullable=False),
    sa.Column('end_datetime', sa.DateTime(timezone=True), nullable=False),
    # CORRECCIÓN AQUÍ: Usar postgresql.ENUM con el nombre del tipo y create_type=False
    # ya que hemos creado el tipo manualmente arriba con op.execute.
    sa.Column('status', postgresql.ENUM(*appointment_status_enum_values, name=appointment_status_type_name, create_type=False), nullable=False),
    sa.Column('notes_client', sa.Text(), nullable=True),
    sa.Column('notes_provider', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['client_id'], ['users.user_id'], name=op.f('fk_appointments_client_id_users'), ondelete='SET NULL'), # Añadido 'name'
    sa.ForeignKeyConstraint(['provider_id'], ['providers.provider_id'], name=op.f('fk_appointments_provider_id_providers'), ondelete='CASCADE'), # Añadido 'name'
    sa.ForeignKeyConstraint(['service_id'], ['services.id'], name=op.f('fk_appointments_service_id_services'), ondelete='SET NULL'), # Añadido 'name'
    sa.PrimaryKeyConstraint('id', name=op.f('pk_appointments')) # Añadido 'name'
    )
    # Los batch_alter_table para índices ya están bien generados por Alembic
    with op.batch_alter_table('appointments', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_appointments_client_id'), ['client_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_appointments_provider_id'), ['provider_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_appointments_service_id'), ['service_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_appointments_start_datetime'), ['start_datetime'], unique=False)
        # El índice para 'status' también debería usar el nombre del tipo ENUM si es necesario
        # pero a menudo un índice en una columna ENUM no es tan diferente de un String.
        # Alembic lo generó así, así que lo dejamos por ahora.
        batch_op.create_index(batch_op.f('ix_appointments_status'), ['status'], unique=False)

    # Los siguientes batch_alter_table son ajustes que Alembic detectó
    # para asegurar la consistencia de FKs y UNIQUEs, o añadir índices que faltaban.
    # A menudo son correctos.
    with op.batch_alter_table('providers', schema=None) as batch_op:
        # Alembic está ajustando la FK para asegurar el ondelete='CASCADE'
        # Si ya existía, puede que la dropee y la cree de nuevo con el nuevo 'name' y ondelete.
        # El 'None' como nombre de la constraint es para que Alembic genere uno.
        batch_op.drop_constraint('providers_provider_id_fkey', type_='foreignkey') # Asume que existía una con este nombre
        batch_op.create_foreign_key(batch_op.f('fk_providers_provider_id_users'), 'users', ['provider_id'], ['user_id'], ondelete='CASCADE')

    with op.batch_alter_table('services', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_services_provider_id'), ['provider_id'], unique=False)
        # Similarmente, ajustando la FK para ondelete='CASCADE'
        batch_op.drop_constraint('services_provider_id_fkey', type_='foreignkey') # Asume que existía una con este nombre
        batch_op.create_foreign_key(batch_op.f('fk_services_provider_id_providers'), 'providers', ['provider_id'], ['provider_id'], ondelete='CASCADE')

    with op.batch_alter_table('users', schema=None) as batch_op:
        # Ajustando la restricción UNIQUE para email para usar el formato de nombrado de Alembic
        # y asegurar que sea un índice también.
        batch_op.drop_constraint('users_email_key', type_='unique') # Asume que existía una con este nombre
        batch_op.create_index(batch_op.f('ix_users_email'), ['email'], unique=True)
        batch_op.create_index(batch_op.f('ix_users_role'), ['role'], unique=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_users_role'))
        batch_op.drop_index(batch_op.f('ix_users_email'))
        # Recrear la restricción unique original si se hace downgrade (nombre puede variar)
        batch_op.create_unique_constraint('users_email_key', ['email'])


    with op.batch_alter_table('services', schema=None) as batch_op:
        batch_op.drop_constraint(batch_op.f('fk_services_provider_id_providers'), type_='foreignkey')
        # Recrear la FK original si se hace downgrade (nombre puede variar)
        batch_op.create_foreign_key('services_provider_id_fkey', 'providers', ['provider_id'], ['provider_id'])
        batch_op.drop_index(batch_op.f('ix_services_provider_id'))

    with op.batch_alter_table('providers', schema=None) as batch_op:
        batch_op.drop_constraint(batch_op.f('fk_providers_provider_id_users'), type_='foreignkey')
        # Recrear la FK original si se hace downgrade (nombre puede variar)
        batch_op.create_foreign_key('providers_provider_id_fkey', 'users', ['provider_id'], ['user_id'])

    with op.batch_alter_table('appointments', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_appointments_status'))
        batch_op.drop_index(batch_op.f('ix_appointments_start_datetime'))
        batch_op.drop_index(batch_op.f('ix_appointments_service_id'))
        batch_op.drop_index(batch_op.f('ix_appointments_provider_id'))
        batch_op.drop_index(batch_op.f('ix_appointments_client_id'))

    op.drop_table('appointments')
    with op.batch_alter_table('time_blocks', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_time_blocks_provider_id'))

    op.drop_table('time_blocks')
    with op.batch_alter_table('availability_rules', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_availability_rules_provider_id'))

    op.drop_table('availability_rules')

    # --- Eliminación del tipo ENUM de PostgreSQL para AppointmentStatus ---
    # Eliminamos el tipo ENUM después de eliminar la tabla que lo usa.
    op.execute(f"DROP TYPE {appointment_status_type_name};")

    # ### end Alembic commands ###